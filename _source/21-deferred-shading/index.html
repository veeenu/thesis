---
layout: proto
title: "Deferred shading + Screen Space Ambient Occlusion"
---
<script type='application/x-vertex-shader' id='vertex-deferred'>

uniform mat4 projection, view, model;
uniform mat3 mnormal;

attribute vec3 vertex, normal;

varying vec4 vposition;
varying vec3 vnormal;
varying float vdepth;

void main() {
  
  vec4 camPos = view * model * vec4(vertex, 1.);
  gl_Position = projection * camPos;
  vnormal = mnormal * normal;
  vposition = camPos;
  vdepth = gl_Position.z / gl_Position.w;

}

</script>
<script type='application/x-fragment-shader' id='fragment-deferred'> 
#extension GL_EXT_draw_buffers : require

precision highp float;

varying vec4 vposition;
varying vec3 vnormal;
varying float vdepth;

const vec3 lightDir = vec3(0., -1., 1.),
           color    = vec3(1., 1., 1.);

void main() {
  //float lambert = .3 + max(dot(normalize(lightDir), vnormal), 0.);

  //gl_FragColor = vec4(color * lambert, 1.);
  gl_FragData[0] = vec4(normalize(vnormal), 1.);
  gl_FragData[1] = vec4(vposition.xyz, 1.);
  gl_FragData[2] = vec4(color, 1.);
  gl_FragData[3] = vec4(vec3(vdepth), 1.);
}

</script>

<script type='application/x-vertex-shader' id='vertex-lighting'>

attribute vec2 position;

varying vec2 vposition;

void main() {
  gl_Position = vec4(position, 0., 1.);
  vposition = .5 + .5 * position;
}

</script>
<script type='application/x-fragment-shader' id='fragment-lighting'> 

#extension GL_OES_standard_derivatives : enable
precision highp float;

uniform sampler2D depthTex, normalTex, positionTex, colorTex;
uniform vec3 lightPos[4];
uniform bool doccl;

varying vec2 vposition;

//const vec3 lightPos = vec3(1., 0., 1.);

float sample(vec4 p, vec4 n, vec2 uv) {
  vec3 dstP = texture2D(positionTex, uv).xyz,
       posV = dstP - p.xyz;

  float intens = max(dot(normalize(posV), n.xyz) - .5, 0.),
        dist = length(posV),
        att  = 1. / (2. + (5. * dist));
  return intens * att;
}

highp float rand(vec2 co)
{
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt= dot(co.xy ,vec2(a,b));
    highp float sn= mod(dt,3.14);
    return fract(sin(sn) * c);
}

#define DL 2.399963229728653
#define EULER 2.718281828459045

vec2 vrand( const vec2 coord ) {
 
  vec2 noise;
 
  float nx = dot ( coord, vec2( 12.9898, 78.233 ) );
  float ny = dot ( coord, vec2( 12.9898, 78.233 ) * 2.0 );
 
  noise = clamp( fract ( 43758.5453 * sin( vec2( nx, ny ) ) ), 0.0, 1.0 );
 
  return ( noise * 2.0  - 1.0 ) * .0003;
 
}

float readDepth(const vec2 coord) {
  return texture2D(depthTex, coord).x;
  //return (2. * .001) / (1000.001 - texture2D(depthTex, coord).x * 999.999);
}

float cmpDepth(const float d1, const float d2, inout int far) {

  float ga = 2., diff = (d1 - d2) * 100.;

  if(diff < .2)
    ga = .1;
  else
    far = 1;

  float dd = diff - .2,
        gauss = pow(EULER, -2. * dd * dd / (ga * ga));
  
  return gauss;
}

float calcAO(float depth, vec2 uv, float dw, float dh) {
  float dd = 1. / depth; //2. - depth * 2.;

  vec2 vv = vec2(dw, dh),
       coord1 = uv + dd * vv,
       coord2 = uv - dd * vv;

  int far = 0;
  float tmp1 = 0., tmp2 = 0.;
  
  tmp1 = cmpDepth(depth, readDepth(coord1), far);
  if(far > 0) {
    tmp2 = cmpDepth(readDepth(coord2), depth, far);
    tmp1 += (1. - tmp1) * tmp2;
  }

  return tmp1;
}

void main() {

  vec4  normal = texture2D(normalTex, vposition),
        color  = texture2D(colorTex, vposition),
        pos    = texture2D(positionTex, vposition),
        depth  = texture2D(depthTex, vposition);

  vec3 lambert = vec3(.1), lCols[4];
  lCols[0] = vec3(1., 0., 0.);
  lCols[1] = vec3(0., 1., 0.);
  lCols[2] = vec3(0., 0., 1.);
  lCols[3] = vec3(1., 1., 1.);

  for(int i = 0; i < 4; ++i) {
    vec3 lightDir = lightPos[i] - pos.xyz; // - pos.xyz;
    float dist = length(lightDir),
          att = 3. / (1. + 1500. * dist + 3000. * dist * dist);

    lambert += lCols[i] * att * max(dot(normalize(lightDir), normal.xyz), 0.);
  }

  vec2 coord = vposition;
  float occlusion = 0., vdepth = readDepth(coord);
  vec2 noisev = vrand(coord);

  float w = (1. / 1280.) / vdepth + (noisev.x * (1. - noisev.x)),
        h = (1. / 800.)  / vdepth + (noisev.y * (1. - noisev.y)),
        dz = 1. / 16.,
        z = 1. - dz / 2.,
        l = 0.;
  for(int i = 0; i < 16; i++) {
    float r = sqrt(1. - z),
          pw = cos(l) * r,
          ph = sin(l) * r;
    occlusion += calcAO(vdepth, coord, pw * w, ph * h);
    z -= dz;
    l += DL;
  }
  occlusion *= dz;

  /*vec2 fw = vec2(.01, .01);
  vec2 kernel[4];
  kernel[0] = vec2(0., 1.);
  kernel[1] = vec2(1., 0.);
  kernel[2] = vec2(0., -1.);
  kernel[3] = vec2(-1., 0.);

  const float sin45 = .707107, sRad = 20.;

  float occlusion = 0., kRad = sRad * (1. - depth.r);

  for(int i = 0; i < 4; ++i) {
    vec2 k1 = reflect(kernel[i], vec2(rand(vposition), rand(-vposition)));
    vec2 k2 = vec2(k1.x * sin45 - k1.y * sin45,
                   k1.x * sin45 + k1.y * sin45);
    occlusion += sample(pos, normal, vposition + k1 * kRad);
    occlusion += sample(pos, normal, vposition + k1 * kRad * .75);
    occlusion += sample(pos, normal, vposition + k1 * kRad * .5);
    occlusion += sample(pos, normal, vposition + k1 * kRad * .25);
  }
  occlusion /= 16.;
  occlusion = clamp(occlusion, 0., 1.);
  if(doccl) occlusion = 0.;*/

  //gl_FragColor = vec4(depth.xyz, 1.);
  gl_FragColor = vec4(vec3(1. - occlusion), 1.);
  //gl_FragColor = vec4(vec3(vdepth), 1.);
  //gl_FragColor = vec4(lambert * color.xyz - occlusion, 1.);
}

</script>

<script src='stats.min.js'></script>
<script src='gl-matrix-min.js'></script>
